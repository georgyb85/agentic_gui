# Source Code vs Executable Mystery

## The Puzzle

We have discovered a fascinating discrepancy between the TSSB source code and the actual executable behavior for the Volume Momentum indicator.

## Evidence

### Source Code (comp_var.cpp, lines 1416-1437)

```cpp
denom = exp ( log ( (double) mult ) / 3.0 ) ;  // Line 1416: Cube root calculated
for (icase=front_bad ; icase<n ; icase++) {

   short_sum = 0.0 ;
   for (k=icase-short_length+1 ; k<=icase ; k++)
      short_sum += volume[k] ;

   long_sum = short_sum ;
   for (k=icase-long_length+1 ; k<icase-short_length+1 ; k++)
      long_sum += volume[k] ;

   short_sum /= short_length ;
   long_sum /= long_length ;

   if (long_sum > 0.0  &&  short_sum > 0.0) {
      output[icase] = log ( short_sum / long_sum ) / denom ;  // Line 1431: DIVISION BY DENOM
      output[icase] = 100.0 * normal_cdf ( 3.0 * output[icase] ) - 50.0 ;
   }
   else
      output[icase] = 0.0 ;
}
```

**Key line 1431**: `output[icase] = log ( short_sum / long_sum ) / denom ;`

The source code **DOES** divide by `denom` (the cube root of multiplier).

### CSV Output Behavior (TSSB_125.exe)

Testing against `BTC25_3 HM.CSV` generated by TSSB_125.exe:

**When implementing WITH division by denom (following source code):**
```
VOL_MOM_S: MAE = 8.404, Status: ✗ HIGH ERROR
VOL_MOM_L: MAE = 7.194, Status: ✗ HIGH ERROR
```

**When implementing WITHOUT division by denom:**
```
VOL_MOM_S: MAE = 0.0000, Status: ✓✓✓ PERFECT MATCH
VOL_MOM_L: MAE = 0.0000, Status: ✓✓✓ PERFECT MATCH
```

## The Mystery

**The executable behavior does NOT match the source code we have.**

## Numerical Proof

Bar 1078, VOL_MOM_S (short_length=10, mult=5):
- short_mean = 1104.04
- long_mean = 1483.19
- denom = exp(log(5)/3) = 1.70998

**If following source code (WITH division):**
```
raw = log(1104.04/1483.19) / 1.70998 = -0.295222 / 1.70998 = -0.172647
scaled = 3.0 * -0.172647 = -0.51794
output = 100 * Φ(-0.51794) - 50 = -19.775
```

**CSV value from TSSB_125.exe:**
```
-31.210104
```

**If NOT dividing by denom:**
```
raw = log(1104.04/1483.19) = -0.295222
scaled = 3.0 * -0.295222 = -0.885666
output = 100 * Φ(-0.885666) - 50 = -31.210
```

**Perfect match!**

## Possible Explanations

### Hypothesis 1: Different Source Version
The source code we have (`Single/comp_var.cpp`) may be from a different version than what was used to compile `TSSB_125.exe`.

- **TSSB_125.exe date**: June 25, 2015 (or later)
- **Source code date**: Unknown (need to check)
- The book was published in 2018, source code may have been "corrected" to match book after executable was compiled

### Hypothesis 2: Compiler Bug/Optimization
Unlikely, but possible:
- Compiler optimization incorrectly eliminated the division
- Would need to be a very specific bug that only affects this one line

### Hypothesis 3: Conditional Compilation
There may be preprocessor directives we haven't found:
```cpp
#ifdef LEGACY_VOLUME_MOMENTUM
   output[icase] = log ( short_sum / long_sum ) ;
#else
   output[icase] = log ( short_sum / long_sum ) / denom ;
#endif
```

### Hypothesis 4: Source Code Updated Post-Release
Most likely scenario:
1. Original TSSB executable was compiled with formula: `log(ratio)` (no division)
2. Users/author noticed discrepancy with book formula
3. Source code was later updated to match book: `log(ratio) / denom`
4. Executable was never recompiled and redistributed
5. Users continued using original executable, unaware of discrepancy

## Evidence Supporting Hypothesis 4

1. **Only Volume Momentum affected**: All other indicators match perfectly between source and executable
2. **Book formula matches updated source**: Suggests source was changed to align with book
3. **Executable still uses old formula**: Suggests executable was never updated
4. **No conditional compilation found**: No preprocessor directives in the volume momentum code

## Implications

### For Traders
Anyone who:
- Read the book and implemented the formula manually
- Used TSSB executable to generate training data
- Built trading systems on this data

Would have **mismatched implementations** unless they validated against CSV output.

### For Research Reproducibility
This creates a serious reproducibility issue:
- Published results using TSSB executable cannot be reproduced using book formulas
- Source code doesn't match executable behavior
- No way to know which version is "correct"

### For Our Implementation
We chose to match the **executable behavior** (without division) because:
1. That's what actual TSSB users have been working with
2. CSV files in the wild were generated by the executable
3. Models trained on TSSB data expect this scaling
4. Easier to validate our implementation against known CSV output

## Verification Steps Taken

1. ✓ Confirmed source code contains division by denom (line 1431)
2. ✓ Confirmed CSV output does NOT match source code formula
3. ✓ Confirmed CSV output matches formula WITHOUT division
4. ✓ Verified all other indicators match between source and executable
5. ✓ Tested with multiple parameter combinations (both match without division)

## Recommendation

**Use the executable behavior** (without cube root division) when implementing Volume Momentum to ensure:
- Compatibility with existing TSSB-generated CSV files
- Compatibility with models trained on TSSB data
- Ability to validate against reference output

**Document the discrepancy** prominently so users understand:
- Source code and executable don't match
- We follow executable behavior for practical reasons
- Book formula has additional divisor that executable doesn't use

## Files

- **Executable**: `TSSB_125.exe` (June 25, date unknown)
- **Source**: `Single/comp_var.cpp` lines 1390-1437
- **Book**: "Testing and Tuning Market Trading Systems", pages 206-207, Equations 7.25-7.26
- **Our Implementation**: `src/SingleIndicatorLibrary.cpp` lines 1087-1144

## Open Questions

1. When was the source code updated relative to executable compilation?
2. Was the discrepancy ever documented in release notes or errata?
3. Are there other indicators with source/executable mismatches we haven't found?
4. Which version performs better in actual trading?

## Action Items for Future

- [ ] Test trading performance of both formulas to see which is better
- [ ] Check if author has commented on this discrepancy
- [ ] Look for other potential source/executable mismatches
- [ ] Consider providing both implementations as options
