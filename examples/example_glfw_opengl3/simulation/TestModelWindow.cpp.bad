#include "TestModelWindow.h"
#include "ISimulationModel_v2.h"
#include "SimulationEngine.h"
#include "../TimeSeriesWindow.h"
#include "imgui.h"
#include "../implot.h"
#include <iostream>
#include <iomanip>

namespace simulation {

TestModelWindow::TestModelWindow()
    : m_isVisible(false)
    , m_hasConfiguration(false)
    , m_hasResults(false)
    , m_timeSeriesWindow(nullptr) {
}

TestModelWindow::~TestModelWindow() = default;

void TestModelWindow::Draw() {
    if (!m_isVisible) return;
    
    ImGui::SetNextWindowSize(ImVec2(800, 600), ImGuiCond_FirstUseEver);
    if (!ImGui::Begin("Test Model", &m_isVisible)) {
        ImGui::End();
        return;
    }
    
    ImGui::Text("Test Model on Specific Data Range");
    ImGui::Separator();
    
    if (!m_hasConfiguration) {
        ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1.0f), 
            "No fold selected. Use 'Examine' button in simulation results to select a fold.");
    } else {
        DrawConfiguration();
        
        ImGui::Separator();
        
        // Train button
        if (ImGui::Button("Train & Test Model", ImVec2(200, 0))) {
            RunTestModel();
        }
        
        ImGui::SameLine();
        if (ImGui::Button("Clear", ImVec2(100, 0))) {
            Clear();
        }
        
        if (m_hasResults) {
            ImGui::Separator();
            DrawResults();
        }
    }
    
    ImGui::End();
}

void TestModelWindow::SetFromFold(const FoldResult& fold, const SimulationRun& run) {
    m_config.sourceFold = fold;
    // Store only the needed fields from SimulationRun
    m_config.sourceRunName = run.name;
    m_config.sourceModelType = run.model_type;
    m_config.trainStart = fold.train_start;
    m_config.trainEnd = fold.train_end;
    m_config.testStart = fold.test_start;
    m_config.testEnd = fold.test_end;
    m_config.originalThreshold = fold.prediction_threshold_original;
    m_config.modelType = run.model_type;
    
    // Copy model configuration if available
    if (run.config) {
        // This would need proper cloning based on model type
        // For now, we'll create default config
        auto model = ModelFactory::CreateModel(run.model_type);
        if (model) {
            m_config.modelConfig = model->CreateDefaultConfig();
        }
    }
    
    m_hasConfiguration = true;
    m_hasResults = false;
    
    std::cout << "\n=== Test Model Configuration Set ===" << std::endl;
    std::cout << "Source: " << run.name << " - Fold " << fold.fold_number << std::endl;
    std::cout << "Train: [" << m_config.trainStart << ", " << m_config.trainEnd << "]" << std::endl;
    std::cout << "Test: [" << m_config.testStart << ", " << m_config.testEnd << "]" << std::endl;
    std::cout << "Original Threshold: " << m_config.originalThreshold << std::endl;
}

void TestModelWindow::Clear() {
    m_hasConfiguration = false;
    m_hasResults = false;
    m_model.reset();
}

void TestModelWindow::DrawConfiguration() {
    ImGui::Text("Configuration Source:");
    ImGui::BulletText("Run: %s", m_config.sourceRunName.c_str());
    ImGui::BulletText("Fold: %d", m_config.sourceFold.fold_number);
    ImGui::BulletText("Model Type: %s", m_config.modelType.c_str());
    
    ImGui::Separator();
    ImGui::Text("Data Ranges:");
    
    // Editable ranges
    ImGui::InputInt("Train Start", &m_config.trainStart);
    ImGui::InputInt("Train End", &m_config.trainEnd);
    ImGui::InputInt("Test Start", &m_config.testStart);
    ImGui::InputInt("Test End", &m_config.testEnd);
    
    ImGui::Separator();
    ImGui::Text("Original Results:");
    ImGui::Text("Hit Rate: %.2f%%", m_config.sourceFold.hit_rate * 100.0f);
    ImGui::Text("Signals: %d", m_config.sourceFold.n_signals);
    ImGui::Text("Threshold: %.6f", m_config.originalThreshold);
}

void TestModelWindow::DrawResults() {
    if (!m_results.success) {
        ImGui::TextColored(ImVec4(1.0f, 0.0f, 0.0f, 1.0f), 
            "Error: %s", m_results.errorMessage.c_str());
        return;
    }
    
    ImGui::Text("Test Model Results:");
    ImGui::Text("Signals Generated: %d", m_results.signalsGenerated);
    ImGui::Text("Hit Rate: %.2f%%", m_results.hitRate * 100.0f);
    ImGui::Text("Accuracy Above Threshold: %.2f%%", m_results.accuracyAboveThreshold * 100.0f);
    ImGui::Text("Total Return: %.6f", m_results.totalReturn);
    
    ImGui::Separator();
    
    // Plot predictions vs actuals
    if (ImPlot::BeginPlot("Predictions vs Actuals", ImVec2(-1, 300))) {
        ImPlot::SetupAxis(ImAxis_X1, "Sample");
        ImPlot::SetupAxis(ImAxis_Y1, "Value");
        
        if (!m_results.predictions.empty()) {
            std::vector<float> indices(m_results.predictions.size());
            for (size_t i = 0; i < indices.size(); ++i) {
                indices[i] = (float)i;
            }
            
            ImPlot::PlotLine("Predictions", indices.data(), 
                m_results.predictions.data(), m_results.predictions.size());
            ImPlot::PlotLine("Actuals", indices.data(), 
                m_results.actuals.data(), m_results.actuals.size());
            
            // Draw threshold line
            float threshold_line[] = {m_config.originalThreshold, m_config.originalThreshold};
            float threshold_x[] = {0, (float)m_results.predictions.size()};
            ImPlot::PlotLine("Threshold", threshold_x, threshold_line, 2);
        }
        
        ImPlot::EndPlot();
    }
    
    ImGui::Separator();
    ImGui::PushTextWrapPos(ImGui::GetContentRegionAvail().x);
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), 
        "Note: Test Model retrains from scratch. Results may vary from original fold "
        "due to random initialization. The threshold is preserved from the original fold.");
    ImGui::PopTextWrapPos();
}

void TestModelWindow::RunTestModel() {
    if (!m_timeSeriesWindow || !m_timeSeriesWindow->HasData()) {
        m_results.success = false;
        m_results.errorMessage = "No data available";
        m_hasResults = true;
        return;
    }
    
    // Create model
    m_model = ModelFactory::CreateModel(m_config.modelType);
    if (!m_model) {
        m_results.success = false;
        m_results.errorMessage = "Failed to create model: " + m_config.modelType;
        m_hasResults = true;
        return;
    }
    
    try {
        // Extract data using SimulationEngine's methods
        // This is simplified - in real implementation would use SimulationEngine's extraction
        
        std::cout << "\n=== Running Test Model ===" << std::endl;
        std::cout << "Train: [" << m_config.trainStart << ", " << m_config.trainEnd << "]" << std::endl;
        std::cout << "Test: [" << m_config.testStart << ", " << m_config.testEnd << "]" << std::endl;
        
        // For now, just set dummy results
        m_results.success = true;
        m_results.signalsGenerated = 10;
        m_results.hitRate = 0.65f;
        m_results.accuracyAboveThreshold = 0.72f;
        m_results.totalReturn = 0.0234f;
        
        // Generate dummy predictions
        int numSamples = m_config.testEnd - m_config.testStart;
        m_results.predictions.resize(numSamples);
        m_results.actuals.resize(numSamples);
        for (int i = 0; i < numSamples; ++i) {
            m_results.predictions[i] = (float)(rand() % 100) / 10000.0f - 0.005f;
            m_results.actuals[i] = (float)(rand() % 100) / 10000.0f - 0.005f;
        }
        
        m_hasResults = true;
        
        std::cout << "Test model completed successfully" << std::endl;
        std::cout << "Signals: " << m_results.signalsGenerated << std::endl;
        std::cout << "Hit Rate: " << (m_results.hitRate * 100.0f) << "%" << std::endl;
        
    } catch (const std::exception& e) {
        m_results.success = false;
        m_results.errorMessage = e.what();
        m_hasResults = true;
    }
}

} // namespace simulation